<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>let's do some graphics</title>
    <link
      href="https://fonts.googleapis.com/css2?family=Inter&display=swap"
      rel="stylesheet"
    />
    <link rel="stylesheet" href="index.css" />
    <!-- the only HTML code we need to make sweet graphics work: -->
    <script type="module" src="dist/graphics-element.js" async></script>
    <link rel="stylesheet" href="dist/graphics-element.css" async />
  </head>
  <body>
    <h1>Putting (interactive) graphics on a web page</h1>

    <p>
      Once up on a time I was involved in
      <a href="http://processingjs.org">Processing.js</a>, a JS port (as best as
      we could do at a time before ES6) of the
      <a href="https://processing.org">Processing language</a>, a visual
      programming language that, to this day, I will whip out whenever I need to
      do some quick trig. And as much as I know why Processing.js is now an
      archived project on github (because I was the one who archived it), I
      still miss it, and I frequently write web pages that would seriously
      benefit from having some interactive graphics on the page. Sure, there's
      <a href="https://p5js.org">P5.js</a> which answers the question "what if
      the web was what it is today, back when the idea of Processing was born",
      but it's not the same. For me, at least. It's a completely different API,
      with a very different "feel", if that makes sense.
    </p>

    <p>
      My most graphics-intensive website is my
      <a href="https://pomax.github.io/bezierinfo">Primer on Bezier curves</a>,
      and that ended up being enough work that I wrote a special graphics
      element for it, that allowed me to write "Processing-ish" code that it
      would server-side render the first frame as placeholder image for, and
      then PWA-style load the real graphic on top of for interactive goodness.
      So what if... I turn that into a web component? Just something you stick
      on a page as a &lt;graphics-element src="..."&gt;&lt;/graphics-element&gt;
      and then you just write your visual thing using a Processing-like flavour
      of JS, with some magic sprinkled in so you're not writing "this." all over
      the place?
    </p>

    <p>
      ...so, yeah, this is that. Let's put some interactive graphics right onto
      the page, using the magic of a custom element! In fact, right click on
      This page and pick "view source": you'll just see a few
      &lt;graphics-element&gt; entries, with normal "src" attributes for the
      graphics that need to be shown.
    </p>

    <p>
      In fact, here's one right now: it shows the result of a
      <a
        href="https://en.wikipedia.org/wiki/Proportional%E2%80%93integral%E2%80%93derivative_controller"
        >PID controller</a
      >
      trying to get an input signal (in red) starting at 0 to reach the target
      value 100 (in blue), by checking its current value, seeing how far off it
      is from the target value, and then generating an output that we then use
      as an update to our input. This means that on the very first run, it'll
      see a difference of 100, and will say "I think you should add 100".
      However, real world signals don't "teleport" form one value to another, so
      it takes a little time for that change to kick in. By the next iteration
      our input may only have risen by around 10, instead of 100. So the PID
      controller goes "okay well I think you should update by 90 now that I'm
      seeing 10 and the target is 100". And we keep running that feedback loop
      forever (or in this case, for as wide as our graphics panel is).
    </p>

    <graphics-element
      title="an example using a PID controller"
      src="./pid-example.js"
      width="650"
      height="300"
      centered="centered"
    ></graphics-element>

    <p>
      The "neat" thing about this is that it'll oscillate: by the time the input
      value actually reaches 100, it's updating so much that it's going to
      "overshoot" the target and now the PID controller's going to try to bring
      the value back down to 100: we see the green PID recommendation curve
      having maxima where the input is at its lowest and its highest, and a
      recommendation of "no change" when the input is at 100, but because of how
      the update feedback works, we'll never stabilize... unless we take the
      accumulated error over time, or the speed at which the input changes, into
      account. Those are the "I" and "D" terms in the name "PID", so if you
      slide their sliders around, you'll see what effect that might have on how
      a signal changes over time when controlled using PID ratios.
    </p>

    <p>
      Of course, that's only "interactive graphics" by using HTML sliders, so
      how about actual interaction? The processing-like library that backs this
      doesn't require you to write your own mouse/touch handling for things like
      "this point should be click-draggable", you instead say which points can
      be moved around, and done: they can now be moved around. So let's look at
      an example of that.
    </p>

    <p>
      In fact, click that "view source" link. I want you to be able to see the
      source code that makes cool things be cool. Because I want you to be able
      to make cool things, too. Let's make the web cool again.
    </p>

    <graphics-element
      title="an example with interactive points"
      src="./point-example.js"
    ></graphics-element>

    <p>
      And yes, that "view source" link is baked into the graphics element
      itself, so that you can always see the code that generates it. No
      pretending that something you put on the web is somehow super secret:
      everything you put on the web is public. That's the very nature of the
      web. IT's what makes it so great: anyone can learn from anyone by looking
      at how they did something.
    </p>

    <p>
      So how about we take things a step further, and actually write a real
      animation? Say, for example, visualising the trigonometric identities of a
      point on a circle: its sine, cosine, tangent, secant, and cosecant values,
      as we move points around?
    </p>

    <p>Sounds good to me, let's go:</p>

    <graphics-element
      title="an example with a play button as well as tap-to-play"
      src="./animated-example.js"
      ><button class="play">play</button></graphics-element
    >

    <p>
      And again, note how little code that needs if you click "view source". In
      fact the bulk of the setup function is just plain JS that adds an event
      listener and updates a text label. That's not even graphics-related,
      that's just page-JS basics.
    </p>

    <p>In fact, let's take that one step further:</p>

    <graphics-element
      src="./trigonometry.js"
      title="A trigonometric identity visualisation"
      width="500"
      height="200"
    >
      <p>
        A point <b>P</b> at some <darkgreen>angle</darkgreen> on a circle has
        several trigonometric identities. The
        <midnightblue>hypotenuse</midnightblue> is the circle's radius, with the
        <red>sine</red> and <blue>cosine</blue> being the point's projection
        onto the y and x axes, respectively. From those, we get the
        <mistyrose>"enclosing right triangle"</mistyrose> with the circle's
        center as the right angle corner, the <darkblue>secant</darkblue> (which
        is just <blue>1/cosine</blue>) as the x-axis corner, and the
        <brown>cosecant</brown> (which is just <red>1/sine</red>) as the y-axis
        corner. Additionally, the point "splits" the enclosing right triangle's
        hypotenuse into two parts: one part, from <b>P</b> to the secant corner,
        has length <orange>tangent</orange> (which is just
        <red>sine</red>/<blue>cosine</blue>), and the other part, from
        <b>P</b> to the cosecant corner, has length
        <purple>cotangent</purple> (which is simply the inverse,
        <blue>cosine</blue>/<red>sine</red>).
      </p>
    </graphics-element>

    <p>
      See all those coloured terms in the text? Mouse-over or tap-and-hold them:
      you'll notice that the correspondingly colored part of the graphic gets
      highlighted in the loudest shade of mint. And don't want all those
      colours? Click the remove button so you can more easily read the text, and
      click "reset" to get the colours back! How does it work? "More HTML!",
      view this page's source and have a look at the HTML that is used for the
      above graphic. Each term is decorated with a tag that uses a CSS color
      name like &lt;black&gt; or &lt;gold&gt; and the graphics-element knows to
      crosslink those into the graphics API's fill and stroke logic. No work on
      your part, just mark a bunch of text with with the same color you use in
      your graphics source code, and done, that's all the highlighting code
      written.
    </p>

    <p>
      This is the kind of thing I wish I had available back when I had to
      archive Processing.js due to a lack of devs, and frankly, interest. The
      need to make cool graphics hasn't gone away. Only the tools to let you do
      so. So hopefully this tool enables at least <em>some</em> folks to make
      <em>some</em> cool things that they otherwise wouldn't have.
    </p>

    <h2>How do I use this?</h2>

    <p>
      All you need to do is grab the
      <a
        href="https://raw.githubusercontent.com/Pomax/custom-graphics-element/main/dist/graphics-element.js"
        download="graphics-element.js"
        >graphics-element.js</a
      >,
      <a
        href="https://raw.githubusercontent.com/Pomax/custom-graphics-element/main/dist/graphics-element.js"
        download="graphics-api.js"
        >graphics-api.js</a
      >
      (for now, I plan on bundling that in, too), and
      <a
        href="https://raw.githubusercontent.com/Pomax/custom-graphics-element/main/dist/graphics-element.css"
        download="graphics-element.css"
        >graphics-element.css</a
      >
      files, put them in a dir that your server can serve them from, and then
      link the graphics-element JS and CSS files on your page:
    </p>

    <pre>
&lt;script type="module" src="graphics-element.js" async&gt;&lt;/script&gt;
&lt;link rel="stylesheet" href="graphics-element.css" async /&gt;</pre
    >

    <p>
      And that's it, you too can now add &lt;graphics-element&gt; to your page.
    </p>

    <h2>Okay but how do I <em>use</em> this? What functions do I call, etc?</h2>

    <p>
      I'm still working on that documentation, but in the mean time the
      <a href="https://github.com/Pomax/custom-graphics-element/tree/main"
        >project page on GitHub</a
      >
      has a whole bunch of information.
    </p>

    <h2>How do I contact you</h2>

    <p>
      Either file an issue over on
      <a href="https://github.com/Pomax/custom-graphics-element/issues"
        >the issue tracker</a
      >
      or just send me a message on Mastodon, where I'm
      <a href="https://mastodon.social/@TheRealPomax"
        >@TheRealPomax on mastodon.social</a
      >
    </p>
  </body>
</html>
