<!doctype html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>Creating a &lt;graphics-element&gt; element.</title>
    <link rel="shortcut icon" href="javascript:">
    <link rel="stylesheet" href="style.css">
    <script src="custom-element/graphics-element.js" type="module" async defer></script>
  </head>

  <!--

    Nice, you actually viewed this page source! As you can see, it's remarkably tidy,
    with only a single script getting loaded to take of teaching the browser how the
    <graphics-element> custom element is supposed to work.

    You may have heard of "React applications" (or "Angular" or "Vue"), and this is not
    that. Things like React are, quite literally, javascript applications that use the
    browser as their interface drawing library. If you were to try to run them with
    Javascript turned off, you'd get an empty page. Not super great!

    The <graphics-element> on this page, however, is a "normal" (and very cool) HTML
    technology called "custom elements", and it's a way for people to invent their
    own HTML elements that are supposed to work the same as any other HTML elements
    you might be familiar with.

    As such, if you have JS disabled, then you still get a perfectly normal page,
    the custom elements just won't "do" anything, but everything else is still right
    there for you to decide whether it looks like it'll be worth turning JS on again.

  -->

  <body>
    <header>
      <h1>Creating a <span>&lt;</span>graphics-element<span>&gt;</span></h1>
    </header>

    <main>
      <section id=practical>
        <p>
          <!--
            As you can see, the first example simply has its code put straight into
            the page itself. There's not a lot to run: it's a non-interactive example,
            and so only has a setup() function that defines a Bezier curve, and a
            draw() function that sets the canvas to a uniform colour, and then draws
            that Bezier curve onto it.
          -->

          <graphics-element
            style="float:left; margin: 0; margin-right: 1em;"
            title="A non-interactive graphic element"
            width="200"
            height="200"
          >
            setup() {
              this.curve = new Bezier(
                this,
                70,140, 10,50, 190,50, 130,140
              );
            }

            draw() {
              clear(`#ccffc8`);
              this.curve.drawSkeleton();
              this.curve.drawCurve();
              this.curve.drawPoints();
            }
          </graphics-element>

          The graphic on the left is a single <code>&lt;graphics-element&gt;</code> element,
          with code that you can view either by inspecting the DOM, or by viewing the page
          source (using cmd-U on Mac, and ctrl+U on everything else). This means anyone can
          see what it does, and how it does that, which means anyone can learn by example.
          Granted, the code uses a <a href="https://processing.org">Processing</a>-esque
          graphics language, so they're not learning JavaScript, but more general programming.
        </p>

        <p>
          <!--
            This second example is a bit more involved: it loads its source code from a
            file that is indicated by the <program-code> element, using a "src" attribute,
            and has several additional HTML elements that the graphic will be able to
            interact with, which you'll see on the page by moving the cursor across
            the canvas and watching the text field's value change, as well as by seeing
            that clicking the "reset" button will, in fact, reset the graphic to its
            initial state.
          -->
          <graphics-element
            style="float:right; margin: 0; margin-left: 1em;"
            title="An interactive graphic element"
            width="400"
            height="200"
          >
            <program-code src="example.js"></program-code>
            <!--
              Your browser probably made that "example.js" attribute a clickable link:
              open it to see what the graphics code for this example looks like!
            -->
            <label>t value: </label><input type="text" value="">
            <button id="reset">reset</button>
          </graphics-element>

          And of course, interactivity is trivially added, as well as loading from a source file. Thankfully,
          the dev tools let you example source as well, so right click the image, pick "inspect element" and
          then open the <code>src</code> link for the </code>to make things even more ridiculous, this is an educational element in the
          sense that if you open your dev tools, and you navigate to the <code>&lt;graphics-element&gt;</code> element,
          and you find its <code>&lt;program-code&gt;</code> element, you can change the program text. After while
          <em>your</em> code will be running. Want to mess around with the colors? Edit the source and
          see what happens. Want to add a fancy event listener? Go for it. If you want to explore, you
          should be able to, so this element will happily let you. You can of course completely break
          things, too, but at least you'll get some error output that'll tell you where things are now
          going wrong. And hey, if things have gone <strong>completely</strong> wrong... just reload the page.
        </p>

        <p>
          -- Pomax
        </p>
      </section>

      <hr>

      <section id=technical>
        <h1>The technical parts</h1>


        <ol>
          <li>
            There is a <code>GraphicsAPI</code> class that wraps a <code>&lt;canvas&gt;</code> element, with
            an API that allows for calls that do things like setting the canvas context fill and stroke styles,
            drawing lines, circles, etc. and having a knowledge of where the mouse is on that canvas.
            However, it can't do anything on its own, and has empty <code>setup()</code> and <code>draw()</code>
            functions (similar to the Processing programmign language) and is intended to be subclassed, with
            that subclass implementing "what should happen" based on those two master functions.
          </li>
          <li>
            The magic happens in the <code>&lt;graphics-element&gt;</code> element. This ingests code either as
            plain textContent, or if there is one, its <code>&lt;program-code&gt;</code> child's <code>src</code>
            attribute.
          </li>
          <li>
            That code gets then gets rewritten to a JS module, which imports the GraphicsAPI, and declares itself
            as extending that class: <code>class Example extends GraphicsApi { ... }</code>. All the "global" code
            gets injected outside the class definition itself, and all the functional code gets injected into the
            class body.
          </li>
          <li>
            Because there is nothing in the custom elements spec that allows scripts to know "which element" they
            are running for, even when they get inserted into a custom element's shadow DOM, some trickery has to
            happen: when the code gets parsed, the <code>&lt;graphics-element&gt;</code> element generates a universal
            id and sets <code>window[uid] = this</code> so that it can be found by <em>any</em> JS that has access
            to the <code>window</code> scope. It then adds one final line to the rewritten code, which invokes
            the <code>Example</code> with that uid as its argument. It then creates a new <code>&lt;script&gt;</code>
            element, sets its type to <code>module</code> and its <code>textContent</code> to the rewritten code,
            and then appends that to the shadow DOM. This causes the script to run.
          </li>
          <li>
            The <code>Example</code> class has no explicit constructor, so when it runs, it falls through to the
            <code>GraphicsAPI</code> constructor, which gets the reference to its "owner" element using
            <code>this.element = window[uid]</code>, and then removes that global binding again, as nothing
            else should ever need to access it during the life of the page (using <code>delete window[uid]</code>).
          </li>
          <li>
            What the <code>GraphicsAPI</code> class <em>does</em> have, though, is its own query selector functions,
            called <code>find()</code> and <code>findAll</code> which searches the owning element's DOM tree,
            which means that graphics code can find and interact with normal on-page content as long as it's
            a child of the <code>&lt;graphics-element&gt;</code> element. You can see this when you view-source
            this page and look at the second example: it has an <code>input</code> and <code>button</code> element
            that get hooked up to the graphics code as it gets run.
          <li>
            Once all that is done, as far as the browser knows, it simply got asked to run an ES module that builds
            an on-page canvas, and interacts with that canvas the same way any other normal page JS does.
          </li>
        </ol>
      </section>
    </main>

    <footer>
      <p>
        Find the code <a href="https://github.com/Pomax/custom-graphics-element">on Github</a>,
        and find me on <a href="https://twitter.com/TheRealPomax">twitter</a> or
        <a href="https://mastodon.social/users/TheRealPomax">Mastodon.social</a>
      </p>
    </footer>
  </body>
</html>
