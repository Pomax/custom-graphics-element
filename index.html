<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>let's do some graphics</title>
    <link
      href="https://fonts.googleapis.com/css2?family=Inter&display=swap"
      rel="stylesheet"
    />
    <link rel="stylesheet" href="index.css" />
    <!-- the only HTML code we need to make sweet graphics work: -->
    <script type="module" src="dist/graphics-element.js" async></script>
    <link rel="stylesheet" href="dist/graphics-element.css" async />
    <style>
      graphics-element table.slider-wrapper {
        background: #ececec;
        margin-bottom: 0.25em;
      }
    </style>
  </head>
  <body>
    <h1>Putting (interactive) graphics on a web page</h1>

    <p>
      If you just want to play with this yourself, hit up the
      <a href="edit/">editor playground</a>, but if you want to know what this
      even is, read on!
    </p>

    <h2>What is this?</h2>

    <p>
      Once up on a time I was involved in
      <a href="http://processingjs.org">Processing.js</a>, a JS port (as best as
      we could do at a time before ES6) of the
      <a href="https://processing.org">Processing language</a>, a visual
      programming language that, to this day, I will whip out whenever I need to
      do some quick trig. And as much as I know why Processing.js is now an
      archived project on github (because I was the one who archived it), I
      still miss it, and I frequently write web pages that would seriously
      benefit from having some interactive graphics on the page. Sure, there's
      <a href="https://p5js.org">P5.js</a> which answers the question "what if
      the web was what it is today, back when the idea of Processing was born",
      but it's not the same. For me, at least. It's a completely different API,
      with a very different "feel", if that makes sense.
    </p>

    <p>
      My most graphics-intensive website is my
      <a href="https://pomax.github.io/bezierinfo">Primer on Bezier curves</a>,
      and that ended up being enough work that I wrote a special graphics
      element for it, which allowed me to write "Processing-ish" code that could
      render the first frame serverside, as a placeholder image, and would then
      PWA-style load the real graphic on top of it if JS is enabled, for
      interactive goodness. So what if I just... turn that into a web component
      that anyone can use? Just something you stick on a page as a
      &lt;graphics-element src="..."&gt;&lt;/graphics-element&gt; and then you
      just write your visual thing using a Processing-like flavour of JS (with
      some magic sprinkled in so you're not prefixing every single function call
      with "<em>this.</em>") and stick that on the web for anyone to use?
    </p>

    <p>
      ...so, yeah, this is that. Let's put some interactive graphics right onto
      the page, using the magic of a custom element! In fact, right click on
      this page and pick "view source": you'll just see a few
      &lt;graphics-element&gt; entries, with normal "src" attributes for the
      graphics that need to be shown.
    </p>

    <p>
      In fact, here's one right now: it shows the result of a
      <a
        href="https://en.wikipedia.org/wiki/Proportional%E2%80%93integral%E2%80%93derivative_controller"
        >PID controller</a
      >
      trying to get a signal (in red) starting at 0 to reach the intended target
      value 100 (in blue), and then a while later, a target value of 50. The way
      it does that is by checking the "current signal value", seeing how far off
      it is from the "desired target value", and then generating an output that
      gets used to update whatever generates the signal. This means that on the
      very first run, it doesn't need to do anything, but the moment the target
      value jumps to 100, it'll see a signal that's at 0, a target that's at
      100, and so it finds a discrepancy of 100. As a result, it will go "I
      think you should add 100". However, real world signals generally don't
      immediately change by large amounts (good luck getting your car from 0 to
      100 in no seconds =D), so in order to apply that change we can only add a
      small amount to our signal, and then on the next iteration the PID
      controller gets to check how far off we are now, and what its recommended
      new change is. Say that by the next iteration our input only managed to
      rise to around 10, instead of all the way to 100. In that case, the PID
      controller will go "okay, well, I think you should update by 90 now that
      I'm seeing 10 and the target is 100". And we keep running that feedback
      loop forever (or in this case, for as wide as our graphics panel is) to
      ensure that "eventually" the signal matches the desired output.
    </p>

    <graphics-element
      title="an example using a PID controller"
      src="./pid-example.js"
      width="650"
      height="300"
      centered="centered"
    ></graphics-element>

    <p>
      The "neat" thing about this is that it'll oscillate: by the time the input
      value actually reaches 100, it's applying such large updates that it's
      going to "overshoot" the target, and now the PID controller is going to
      try to bring the value back down to 100: we see the green PID
      recommendation curve having maxima where the input is at its lowest and
      its highest, and a recommendation of "no change" when the input is at 100,
      but because of how the update feedback works, we'll never stabilize...
      unless we take either the accumulated error over time (the "I" in PID),
      the "speed at which the input changes" (the "D" in PID), or both into
      account. If you slide the P, I, or D sliders around, you'll see what
      effect that might have on how a signal changes over time. With a bit of
      sliding, you might find something like P=0.5, I=0.4, and D=17, and now
      we're in business.
    </p>

    <p>
      Of course, this graphic is only "interactive" in the sense that you get to
      move HTML sliders, so how about some actual interaction? The library that
      backs the graphics element doesn't require you to write your own
      mouse/touch handling for things like "this point should be
      click-draggable", you instead say which points can be moved around, and
      done: they can now be moved around. So let's look at an example of that.
    </p>

    <graphics-element
      title="an example with interactive points"
      src="./point-example.js"
    >
      <source src="add-points.js" type="graphics-code" />
      <p>
        Click-drag (or touch-slide) points to move them around in our graphics
        pane, to reveal a bunch of curves that have been fit to the collection
        of points (there's a polygon, two Bezier curves, a cardinal spline, and
        even a B-spline. Can you identify each?)
      </p>
    </graphics-element>

    <p>
      And click that "view source" link, as well as the "[+1]" link. I want you
      to be able to see the source code that makes cool things be cool. Because
      I want you to be able to make cool things, too. Let's make the web cool
      again. In fact, I want you to be able to not just view source, but
      comfortably work with "lots of code", so you can add more than one source
      file: if you view the page source for the above element, you'll see that
      it has a &lt;source&gt; element in addition to the main "src" attribute:
      this allows you to write graphics in a modular way, where you have have
      one file that's just "the basics" that lets you add additional files for
      extra bits that are relevant to "this specific graphic". In this case, we
      have some general code for drawing points, and then an extra bit of code
      that specifies a bunch of points and adds Bezier and B-spline drawing.
    </p>

    <p>
      And that "view source" link is baked into the graphics element itself, so
      that you can always see what code generated the graphics you're looking
      at. No pretending that something you put on the web is somehow super
      secret: everything you put on the web is public. That's the very nature of
      the web. It's what makes it so great: anyone can learn from anyone by
      looking at how they did something.
    </p>

    <p>
      So how about we take things a step further, and actually write a real
      animation? Say, for example, visualising the trigonometric identities of a
      point on a circle (its sine, cosine, tangent, secant, and cosecant values)
      as we move points around, and then mirror that a few times so we get a
      kaleidoscope going?
    </p>

    <p>Sounds good to me, let's go:</p>

    <graphics-element
      title="an example with a play button as well as tap-to-play"
      src="./animated-example.js"
    ></graphics-element>

    <p>
      And again, if you click "view source" link you'll see that most of the
      code is things that draw lines and set colors: we get to focus on the
      parts that <em>matter</em> without having to bother with all the code that
      we really don't want to have to care about.
    </p>

    <p>In fact, let's take that one step further:</p>

    <graphics-element
      src="./trigonometry.js"
      title="A trigonometric identity visualisation"
      width="500"
      height="200"
    >
      <p>
        A point <b>P</b> at some <darkgreen>angle</darkgreen> on a circle has
        several trigonometric identities. The <red>sine</red> and
        <blue>cosine</blue> are the projection of <b>P</b> onto the y and x
        axes, respectively, and form two sides of
        <lavender>a right angle triangle</lavender>, with a
        <midnightblue>hypotenuse</midnightblue> that is equal to the circle's
        radius. We also see an
        <mistyrose>"enclosing right triangle"</mistyrose> with the circle's
        center as the right angle corner, the point's
        <darkblue>secant</darkblue> (which is just <blue>1/cosine</blue>) as
        x-axis corner, and the point's <brown>cosecant</brown> (which is just
        <red>1/sine</red>) as y-axis corner. Additionally, our point "splits"
        the enclosing right triangle's hypotenuse into two parts: one part, from
        <b>P</b> to the secant corner, has length
        <orange>tangent</orange> (which is just
        <red>sine</red>/<blue>cosine</blue>), and the other part, from
        <b>P</b> to the cosecant corner, has length
        <purple>cotangent</purple> (which is simply the inverse,
        <blue>cosine</blue>/<red>sine</red>).
      </p>
    </graphics-element>

    <p>
      See all those coloured terms in the text? Mouse-over or tap-and-hold them:
      you'll notice that the correspondingly colored part of the graphic gets
      highlighted in the loudest shade of mint. And don't want all those
      colours? Click the remove button so you can more easily read the text, and
      click "reset" to get the colours back! How does it work? "More HTML!",
      view this page's source and have a look at the HTML that is used for the
      above graphic. Each term is decorated with a tag that uses a CSS color
      name like &lt;black&gt; or &lt;gold&gt; and the graphics-element knows to
      cross-link those into the graphics API's fill and stroke logic. No work on
      your part, just mark a bunch of text with with the same color you use in
      your graphics source code, and done, that's all the highlighting code
      written.
    </p>

    <p>
      This is the kind of thing I wish I had available back when I had to
      archive Processing.js due to a lack of devs, and frankly, interest. The
      need to make cool graphics hasn't gone away. Only the tools to let you
      just easily put those on a page have. So hopefully this tool enables at
      least <em>some</em> folks to make <em>some</em> cool things that they
      otherwise wouldn't have. That's all we need: everything more is a bonus.
    </p>

    <h2>How do I use this?</h2>

    <p>
      All you need to do is grab the
      <a href="dist/graphics-element.js" download="graphics-element.js"
        >graphics-element.js</a
      >
      and
      <a href="dist/graphics-element.css" download="graphics-element.css"
        >graphics-element.css</a
      >
      files, put them in a dir that your server can serve them from, and then
      link to the graphics-element JS and CSS files in the &lt;head&gt; of your
      page:
    </p>

    <pre>
&lt;head&gt;
  ...
  &lt;script type="module" src=".../graphics-element.js" async&gt;&lt;/script&gt;
  &lt;link rel="stylesheet" href=".../graphics-element.css" async /&gt;
&lt;/head&gt;</pre
    >

    <p>
      And that's it, you too can now add &lt;graphics-element&gt; to your page.
    </p>

    <h2>Okay but how do I <em>use</em> this? What functions do I call, etc?</h2>

    <p>
      I'm still working on getting the documentation worked into the live site,
      but in the mean time the
      <a href="https://github.com/Pomax/custom-graphics-element/tree/main"
        >project page on GitHub</a
      >
      is both the documentation on how to use this element yourself, as well as
      the API docs that cover all the things you won't have to implement
      yourself if you just want to put graphics on a page or web app. And of
      course, if you want examples... scroll up, and click those "view source"
      links, or click through to the <a href="edit/">editor playground</a> and
      see how far you get =)
    </p>

    <h2>How do I contact you?</h2>

    <p>
      Either file an issue over on
      <a href="https://github.com/Pomax/custom-graphics-element/issues"
        >the issue tracker</a
      >, or just send me a message on Mastodon, where I'm
      <a href="https://mastodon.social/@TheRealPomax"
        >@TheRealPomax on mastodon.social</a
      >
    </p>
  </body>
</html>
