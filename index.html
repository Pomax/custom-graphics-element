<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>let's do some graphics</title>
    <link
      href="https://fonts.googleapis.com/css2?family=Inter&display=swap"
      rel="stylesheet"
    />
    <link rel="stylesheet" href="index.css" />
    <!-- the only HTML code we need to make sweet graphics work: -->
    <script type="module" src="dist/graphics-element.js" async></script>
    <link rel="stylesheet" href="dist/graphics-element.css" async />
  </head>
  <body>
    <h1>Putting (interactive) graphics on a web page</h1>

    <p>
      Once up on a time I was involved in
      <a href="http://processingjs.org">Processing.js</a>, a JS port (as best as
      we could do at a time before ES6) of the
      <a href="https://processing.org">Processing language</a>, a visual
      programming language that, to this day, I will whip out whenever I need to
      do some quick trig. And as much as I know why Processing.js is now an
      archived project on github (because I was the one who archived it), I
      still miss it, and I frequently write web pages that would seriously
      benefit from having some interactive graphics on the page. Sure, there's
      <a href="https://p5js.org">P5.js</a> which answers the question "what if
      the web was what it is today, back when the idea of Processing was born",
      but it's not the same. For me, at least. It's a completely different API,
      with a very different "feel", if that makes sense.
    </p>

    <p>
      My most graphics-intensive website is my
      <a href="https://pomax.github.io/bezierinfo">Primer on Bezier curves</a>,
      and that ended up being enough work that I wrote a special graphics
      element for it, that allowed me to write "Processing-ish" code that it
      would server-side render the first frame as placeholder image for, and
      then PWA-style load the real graphic on top of for interactive goodness.
      So what if... I turn that into a web component? Just something you stick
      on a page as a &lt;graphics-element src="..."&gt;&lt;/graphics-element&gt;
      and then you just write your visual thing using a Processing-like flavour
      of JS, with some magic sprinkled in so you're not writing "this." all over
      the place?
    </p>

    <p>
      ...so, yeah, this is that. Let's put some interactive graphics right onto
      the page, using the magic of a custom element! In fact, right click on
      This page and pick "view source": you'll just see a few
      &lt;graphics-element&gt; entries, with normal "src" attributes for the
      graphics that need to be shown.
    </p>

    <p>
      In fact, here's one right now: it shows the result of a
      <a
        href="https://en.wikipedia.org/wiki/Proportional%E2%80%93integral%E2%80%93derivative_controller"
        >PID controller</a
      >
      trying to get an signal (in red) starting at 0 to reach the target value
      100 (in blue), and then after a while, a target value of 50, by checking
      the current signal value, seeing how far off it is from the target value,
      and then generating an output that gets used to update "the thing that
      generates the signal". This means that on the very first run, it doesn't
      need to do anything, but the moment the target value jumps to 100, it'll
      see a signal that's at 0, a target that's 100, and so finds a discrepancy
      of 100. And so, it will go "I think you should add 100". However, real
      world signals don't magically just "become a new value", so in order to
      apply that change, we can only add a small amount to our signal, and then
      on the next iteration the PID controller gets to check how far off we are
      now, and what its recommended new change is. Say that by the next
      iteration our input only have rose by around 10, instead of 100. In that
      case, the PID controller goes "okay, well, I think you should update by 90
      now that I'm seeing 10 and the target is 100". And we keep running that
      feedback loop forever (or in this case, for as wide as our graphics panel
      is).
    </p>

    <graphics-element
      title="an example using a PID controller"
      src="./pid-example.js"
      width="650"
      height="300"
      centered="centered"
    ></graphics-element>

    <p>
      The "neat" thing about this is that it'll oscillate: by the time the input
      value actually reaches 100, it's updating so much that it's going to
      "overshoot" the target and now the PID controller's going to try to bring
      the value back down to 100: we see the green PID recommendation curve
      having maxima where the input is at its lowest and its highest, and a
      recommendation of "no change" when the input is at 100, but because of how
      the update feedback works, we'll never stabilize... unless we take the
      accumulated error over time, or "the speed at which the input changes",
      into account. Those are the "I" and "D" terms in the name "PID", so if you
      slide their sliders around, you'll see what effect that might have on how
      a signal changes over time when controlled using PID ratios. With a bit of
      sliding, you might find something like P=0.5, I=0.4, and D=17, and now
      we're in business.
    </p>

    <p>
      Of course, this graphic is only "interactive" in the sense that you get to
      move HTML sliders, so how about some actual interaction? The library that
      backs the grahpics element doesn't require you to write your own
      mouse/touch handling for things like "this point should be
      click-draggable", you instead say which points can be moved around, and
      done: they can now be moved around. So let's look at an example of that.
    </p>

    <graphics-element
      title="an example with interactive points"
      src="./point-example.js"
      ><p>
        Click-drag (or touch-slide) points to move them around in our graphics
        pane, and reveal a bunch of curves that have been fit to our point
        collection (there's a polygon, two Bezier curves, a cardinal spline, and
        even a B-spline. Can you identify each?)
      </p></graphics-element
    >

    <p>
      In fact, click that "view source" link. I want you to be able to see the
      source code that makes cool things be cool. Because I want you to be able
      to make cool things, too. Let's make the web cool again.
    </p>

    <p>
      And yes, that "view source" link is baked into the graphics element
      itself, so that you can always see the code that generates it. No
      pretending that something you put on the web is somehow super secret:
      everything you put on the web is public. That's the very nature of the
      web. IT's what makes it so great: anyone can learn from anyone by looking
      at how they did something.
    </p>

    <p>
      So how about we take things a step further, and actually write a real
      animation? Say, for example, visualising the trigonometric identities of a
      point on a circle: its sine, cosine, tangent, secant, and cosecant values,
      as we move points around?
    </p>

    <p>Sounds good to me, let's go:</p>

    <graphics-element
      title="an example with a play button as well as tap-to-play"
      src="./animated-example.js"
      ><button class="play">play</button></graphics-element
    >

    <p>
      And again, note how little code that needs if you click "view source". In
      fact the bulk of the setup function is just plain JS that adds an event
      listener and updates a text label. That's not even graphics-related,
      that's just page-JS basics.
    </p>

    <p>In fact, let's take that one step further:</p>

    <graphics-element
      src="./trigonometry.js"
      title="A trigonometric identity visualisation"
      width="500"
      height="200"
    >
      <p>
        A point <b>P</b> at some <darkgreen>angle</darkgreen> on a circle has
        several trigonometric identities. The <red>sine</red> and
        <blue>cosine</blue> are the projection of <b>P</b> onto the y and x
        axes, respectively, and form two sides of
        <lavender>a right angle triangle</lavender>, with a
        <midnightblue>hypotenuse</midnightblue> that is equal to the circle's
        radius. We also see an
        <mistyrose>"enclosing right triangle"</mistyrose> with the circle's
        center as the right angle corner, the point's
        <darkblue>secant</darkblue> (which is just <blue>1/cosine</blue>) as
        x-axis corner, and the point's <brown>cosecant</brown> (which is just
        <red>1/sine</red>) as y-axis corner. Additionally, our point "splits"
        the enclosing right triangle's hypotenuse into two parts: one part, from
        <b>P</b> to the secant corner, has length
        <orange>tangent</orange> (which is just
        <red>sine</red>/<blue>cosine</blue>), and the other part, from
        <b>P</b> to the cosecant corner, has length
        <purple>cotangent</purple> (which is simply the inverse,
        <blue>cosine</blue>/<red>sine</red>).
      </p>
    </graphics-element>

    <p>
      See all those coloured terms in the text? Mouse-over or tap-and-hold them:
      you'll notice that the correspondingly colored part of the graphic gets
      highlighted in the loudest shade of mint. And don't want all those
      colours? Click the remove button so you can more easily read the text, and
      click "reset" to get the colours back! How does it work? "More HTML!",
      view this page's source and have a look at the HTML that is used for the
      above graphic. Each term is decorated with a tag that uses a CSS color
      name like &lt;black&gt; or &lt;gold&gt; and the graphics-element knows to
      crosslink those into the graphics API's fill and stroke logic. No work on
      your part, just mark a bunch of text with with the same color you use in
      your graphics source code, and done, that's all the highlighting code
      written.
    </p>

    <p>
      This is the kind of thing I wish I had available back when I had to
      archive Processing.js due to a lack of devs, and frankly, interest. The
      need to make cool graphics hasn't gone away. Only the tools to let you do
      so. So hopefully this tool enables at least <em>some</em> folks to make
      <em>some</em> cool things that they otherwise wouldn't have.
    </p>

    <h2>How do I use this?</h2>

    <p>
      All you need to do is grab the
      <a href="dist/graphics-element.js" download="graphics-element.js"
        >graphics-element.js</a
      >
      and
      <a href="dist/graphics-element.css" download="graphics-element.css"
        >graphics-element.css</a
      >
      files, put them in a dir that your server can serve them from, and then
      link to the graphics-element JS and CSS files in the &lt;head&gt; of your
      page:
    </p>

    <pre>
&lt;head&gt;
  ...
  &lt;script type="module" src="graphics-element.js" async&gt;&lt;/script&gt;
  &lt;link rel="stylesheet" href="graphics-element.css" async /&gt;
&lt;/head&gt;</pre
    >

    <p>
      And that's it, you too can now add &lt;graphics-element&gt; to your page.
    </p>

    <h2>Okay but how do I <em>use</em> this? What functions do I call, etc?</h2>

    <p>
      I'm still working on getting the documentation worked into the live site,
      but in the mean time the
      <a href="https://github.com/Pomax/custom-graphics-element/tree/main"
        >project page on GitHub</a
      >
      is both the documentation on how to use this element yourself, as well as
      the API docs that cover all the things you won't have to implement
      yourself if you just want to put graphics on a page or web app. And of
      course, if you want examples... scroll up, and click those "view source"
      links =)
    </p>

    <h2>How do I contact you?</h2>

    <p>
      Either file an issue over on
      <a href="https://github.com/Pomax/custom-graphics-element/issues"
        >the issue tracker</a
      >, or just send me a message on Mastodon, where I'm
      <a href="https://mastodon.social/@TheRealPomax"
        >@TheRealPomax on mastodon.social</a
      >
    </p>
  </body>
</html>
