<!doctype html>
<html>
  <head>
    <meta charset="UTF-8">
    <link rel="shortcut icon" href="javascript:">

    <!--

      Nice, you actually decided to keep under the hood! As you can see, it's remarkably
      tidy, with only a single script getting loaded to take of teaching the browser how
      the <graphics-element> custom element is supposed to work.

      You may have heard of "React applications" (or "Angular" or "Vue"), and this is not
      that. Things like React are, quite literally, javascript applications that use the
      browser as their interface drawing library. If you were to try to run them with
      Javascript turned off, you'd get an empty page. Not super great!

      The <graphics-element> on this page, however, is a "normal" (and very cool) HTML
      technology called "custom elements", and it's a way for people to invent their
      own HTML elements that are supposed to work the same as any other HTML elements
      you might be familiar with.

      As such, if you have JS disabled, then you still get a perfectly normal page,
      the custom elements just won't "do" anything, but everything else is still right
      there for you to decide whether it looks like it'll be worth turning JS on again.

    -->

    <title>Creating a &lt;graphics-element&gt; element.</title>

    <!--
      This is the only script required to make sure our <graphics-element> will work:
    -->

    <script src="custom-element/graphics-element.js" type="module" async defer></script>

    <!--
      And you may want to have a look at the style.css later, to see how it makes sure
      that there is fallback content to show ont he page even when our <graphics-element>
      hasn't been loaded, either because it's still in the process of loading, or because
      someone is viewing the page with Javascript disabled.
    -->

    <link rel="stylesheet" href="style.css">
  </head>

  <body>
    <header>
      <h1>Creating a <span>&lt;</span>graphics-element<span>&gt;</span></h1>
    </header>

    <main>
      <section id=practical>
        <p>
          <!--
            As you can see, the first example simply has its code put straight into
            the page itself. There's not a lot to run: it's a non-interactive example,
            and so only has a setup() function that defines a Bezier curve, and a
            draw() function that sets the canvas to a uniform colour, and then draws
            that Bezier curve onto it.
          -->

          <graphics-element
            style="float:left; margin: 0; margin-right: 1em;"
            title="A non-interactive graphic element"
            width="200"
            height="200"
          >
            <program-code>
              setup() {
                setBorder(1);
                this.curve = new Bezier(
                  this,
                  70,140, 10,50, 190,50, 130,140
                );
              }

              draw() {
                clear(`#ccffc8`);
                this.curve.drawSkeleton();
                this.curve.drawCurve();
                this.curve.drawPoints();
              }
            </program-code>

            <!--
              note that we still want to be able to show something even when Javascript
              is turned off (for whatever reason), we want to offer a fallback image.

              This means we need some CSS in place to ensure that when the <graphics-element>
              tag is not defined, this image and accompanying text shows on the page,
              but does not show if scritps are allowed and the <graphics-element> "works".

              See the "styles.css" file for how we can make that happen!
            -->

            <fallback-image>
              <img class="fallback" src="images/non-interactive.png">
              scripts are disabled, showing placeholder
            </fallback-image>
          </graphics-element>

          The graphic on the left is a single <code>&lt;graphics-element&gt;</code> element,
          with code that you can view either by inspecting the DOM, or by viewing the page
          source (using cmd-U on Mac, and ctrl+U on everything else). This means anyone can
          see what it does, and how it does that, which means anyone can learn by example.
          Granted, the code uses a <a href="https://processing.org">Processing</a>-esque
          graphics language, so they're not learning JavaScript, but more general programming.
        </p>

        <p>
          <!--
            This second example is a bit more involved: it loads its source code from a
            file that is indicated by the <program-code> element, using a "src" attribute,
            and has several additional HTML elements that the graphic will be able to
            interact with, which you'll see on the page by moving the cursor across
            the canvas and watching the text field's value change, as well as by seeing
            that clicking the "reset" button will, in fact, reset the graphic to its
            initial state.
          -->
          <graphics-element
            style="float:right; margin: 0; margin-left: 1em;"
            title="An interactive graphic element"
            width="400"
            height="200"
          >
            <program-code src="example.js"></program-code>

            <!--
              Your browser probably made that "example.js" attribute a clickable link:
              open it to see what the graphics code for this example looks like!
            -->

            <label>"t" value: </label><input type="text" value="">
            <button id="reset">reset</button>

            <!--
              And of course we want a fallback image here, too.
            -->

            <fallback-image>
              <img class="fallback" src="images/interactive.png">
              scripts are disabled, showing placeholder
            </fallback-image>
          </graphics-element>

          And of course, interactivity is trivially added, as well as loading from a source file. Thankfully,
          the dev tools let you example source as well, so right click the image, pick "inspect element" and
          then open the <code>src</code> link for the </code>to make things even more ridiculous, this is an educational element in the
          sense that if you open your dev tools, and you navigate to the <code>&lt;graphics-element&gt;</code> element,
          and you find its <code>&lt;program-code&gt;</code> element, you can change the program text. After while
          <em>your</em> code will be running. Want to mess around with the colors? Edit the source and
          see what happens. Want to add a fancy event listener? Go for it. If you want to explore, you
          should be able to, so this element will happily let you. You can of course completely break
          things, too, but at least you'll get some error output that'll tell you where things are now
          going wrong. And hey, if things have gone <strong>completely</strong> wrong... just reload the page.
        </p>

        <p>
          â€• Pomax
        </p>
      </section>

      <hr>

      <section id=technical>
        <h1>The technical parts</h1>

        <p>
          Essentially, all of this works because the <code>&lt;graphics-element&gt;</code> takes code and uses
          modern template strings syntax to insert that code into a modern JS class that extends a class called
          <code>GraphicsAPI</code>. Once dropped in, creating an instance of this new class will through to the
          GraphicsAPI's constructor, which builds a canvas and calls <code>setup()</code> and then <code>draw()</code>.
        </p>

        <p>
          Of course, some tricks are necessary to make that work: the GraphicsElement code has some naive,
          but rather functional, code that splits up graphics code into "global" code (like imports, and
          global <code>let</code> and <code>const</code>) and "class" code (essentially anthing that
          is a function will end up as class code). This is then injected into simple class scaffolding,
          with a the GraphicsElement's own URL determined by examining <code>import.meta</code>:
        </p>

        <pre>const MODULE_URL = import.meta.url;
const MODULE_PATH = MODULE_URL.slice(0, MODULE_URL.lastIndexOf('/'));

const uid = `ge-uid-${Date.now()}-${Math.random()}`;
window[uid] = this;

const width = this.getAttribute(`width`) || 200;
const height = this.getAttribute(`height`) || 200;

code = `
  import { GraphicsAPI, Bezier, Point } from "${MODULE_PATH}/graphics-api.js";

  ${globalCode}

  class Example extends GraphicsAPI {
    ${classCode}
  }

  new Example("${uid}", ${width}, ${height});
`;</pre>

        <p>
          This is then injected as a <code>&lt;script type="module"&gt;</code> into the shadow DOM, which
          causes the script to be executed, ending in the <code>new Example(...)</code> call that kicks
          off the actual running of graphics on a canvas.
        </p>

        <p>
          One downside of modern custom elements is that there is nothing in the spec that allows scripts
          to know "which element" they are running for when they get inserted into a custom element's shadow DOM,
          and even though "plain" code can check <code>document.currentScript</code>, that property gets
          intentionally set to <code>null</code> when you're loading a module, which we are. So: the only way
          for us to learn which on-page element we should be talking to for script purposes is to temporarily
          pollute the global scope, by creating that <code>window[uid]=this</code> binding, and then inserting
          that same uid into the script itself, allowing it to access <code>window[uid]</code> once it gets
          executed. And then, for good housekeeping, that binding gets deleted immediately upon starting the
          script, but it's still a bit of an unfortunate hack:
        </p>

        <pre>class GraphicsAPI {
  ...
  constructor(uid, width=200, height=200) {
    this.element = window[uid];
    delete window[uid];
    this.canvas = document.createElement(`canvas`);
    this.setSize(width, height);
    this.addListeners();
    this.setup();
    this.draw();
  }
  ...
}</pre>

      <p>
        Of course, without a list of what the GraphicsAPI supports, it's hard to write your own code against it,
        so there will be some API documentation in due time - for now, the focus is still on making sure this
        meets the needs of <a href="https://pomax.github.io/bezierinfo">The Primeron Bezier Curves</a> as part
        of an effort to remove React from that codebase, because right now that's a web app, when it should
        really be a web page, instead. Just because you have JS disabled, should not mean you can't read it.
      </p>
      </section>
    </main>

    <hr>

    <footer>
      <p>
        Find the code <a href="https://github.com/Pomax/custom-graphics-element">on Github</a>,
        and find me on <a href="https://twitter.com/TheRealPomax">twitter</a> or
        <a href="https://mastodon.social/users/TheRealPomax">Mastodon.social</a>
      </p>
    </footer>
  </body>
</html>
